<!DOCTYPE html>
<html>
<head>
    <script src="https://pixijs.download/dev/pixi.min.js"></script>
    <script src="https://unpkg.com/@pixi/sound/dist/pixi-sound.js"></script>
</head>
<body>
    <script>
        const manifest = {
            sprite1: 'assets/sprites/eggHead.png',
            sprite2: 'assets/sprites/flowerTop.png',
            sprite3: 'assets/sprites/helmlok.png',
            sprite4: 'assets/sprites/skully.png',
            sfxloop: 'assets/sfx/loop3.mp3',
            succesSfx: 'assets/sfx/success.mp3',
        };

        const symbols = [
            manifest.sprite1,
            manifest.sprite2,
            manifest.sprite3,
            manifest.sprite4
        ];

        const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        const height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

        const app = new PIXI.Application({ backgroundColor: 0x1099bb, width: width, height: height });
        document.body.appendChild(app.view);

        const REEL_COUNT = 3;

        let money = 1000;
        let betIndex = 3;
        const BET_OPTIONS = [1, 2, 5, 10, 25, 50, 100];

        let slotIds = [];
        //Wrex: We'll have a sort order for the sprite icons so its easily deterministric using getNextSymbolId
        const SLOT_ORDER = [
            [3, 1, 2, 0, 0, 0],
            [0, 2, 1, 3, 1],
            [2, 0, 1, 3],
        ];

        const MARGIN_COUNT = 2;
        const REEL_WIDTH = width / (REEL_COUNT + MARGIN_COUNT);

        const SYMBOLS_VISIBLE = 3;
        const SYMBOL_SIZE = Math.min(height / (SYMBOLS_VISIBLE + MARGIN_COUNT), REEL_WIDTH);

        PIXI.Assets.addBundle('demo', manifest);
        PIXI.Assets.loadBundle('demo').then((resources) => {
            for (var i = 0; i < REEL_COUNT; i++) {
                slotIds[i] = 0;
            }

            let slotTextures = [];
            for (var i = 0; i < symbols.length; i++) {
                slotTextures.push(PIXI.Texture.from(symbols[i]));
            }

            let sound = PIXI.sound.Sound.from(manifest.sfxloop);
            sound.play({
                loop: true,
                singleInstance: true,
                volume: 0.01, //For everyone's sanity
            });

            const reels = [];
            const reelContainer = new PIXI.Container();
            for (let i = 0; i < REEL_COUNT; i++) {
                const rc = new PIXI.Container();
                rc.x = (i + 1) * REEL_WIDTH;
                reelContainer.addChild(rc);

                const reel = {
                    container: rc,
                    symbols: [],
                    position: 0,
                    previousPosition: 0,
                    blur: new PIXI.filters.BlurFilter(),
                };
                reel.blur.blurX = 0;
                reel.blur.blurY = 0;
                rc.filters = [reel.blur];

                //Wrex: +1 being a buffer to show the future one while overscrolling
                for (let j = 0; j < SYMBOLS_VISIBLE + 1; j++) {
                    var symbolId = getNextSymbolId(i);
                    const symbol = new PIXI.Sprite(slotTextures[symbolId]);
                    // Scale the symbol to fit symbol area.
                    symbol.scale.x = symbol.scale.y = Math.min(SYMBOL_SIZE / symbol.width, SYMBOL_SIZE / symbol.height);
                    symbol.x = (REEL_WIDTH / 2) - (symbol.width * symbol.scale.x) / 2;
                    symbol.y = j * SYMBOL_SIZE;
                    reel.symbols.push(symbol);
                    rc.addChild(symbol);
                }
                reels.push(reel);
            }

            function getNextSymbolId(reelId) {
                var nextSlotId = slotIds[reelId];
                var symbolId = SLOT_ORDER[reelId][nextSlotId];
                slotIds[reelId]++;
                slotIds[reelId] %= SLOT_ORDER.length;
                return symbolId;
            }

            // Build top & bottom covers and position reelContainer
            const margin = (app.screen.height - SYMBOL_SIZE * 3) / 2;
            reelContainer.x = Math.round(app.screen.width - REEL_WIDTH * (REEL_COUNT + MARGIN_COUNT));
            reelContainer.y = margin;

            const top = new PIXI.Graphics();
            top.beginFill(0, 1);
            top.drawRect(0, 0, app.screen.width, margin);

            const bottom = new PIXI.Graphics();
            bottom.beginFill(0, 1);
            bottom.drawRect(0, SYMBOL_SIZE * 3 + margin, app.screen.width, margin);

            const left = new PIXI.Graphics();
            left.beginFill(0, 1);
            left.drawRect(0, 0, REEL_WIDTH, app.screen.height);

            const right = new PIXI.Graphics();
            right.beginFill(0, 1);
            right.drawRect(app.screen.width - REEL_WIDTH, 0, REEL_WIDTH, app.screen.height);

            // Add play text
            const titleStyle = new PIXI.TextStyle({
                fontFamily: 'Arial',
                fontSize: 32,
                fontStyle: 'italic',
                fontWeight: 'bold',
                fill: ['#ffff00', '#00ff99'], // gradient
                stroke: '#18501e',
                strokeThickness: 5,
                dropShadow: true,
                dropShadowColor: '#06360b',
                dropShadowBlur: 4,
                dropShadowAngle: Math.PI / 6,
                dropShadowDistance: 6,
                wordWrap: true,
                wordWrapWidth: REEL_WIDTH * 3,
            });

            const infoStyle = new PIXI.TextStyle({
                fontFamily: 'Arial',
                fontSize: 16,
                fontStyle: 'italic',
                fontWeight: 'bold',
                fill: '#ffff00',
                stroke: '#18501e',
                strokeThickness: 5,
            });

            const headerText = new PIXI.Text('WREX SLOTS!', titleStyle);
            headerText.x = Math.round((top.width - headerText.width) / 2);
            headerText.y = Math.round((margin - headerText.height) / 2);
            top.addChild(headerText);

            const playText = new PIXI.Text('Spin the wheel for infinite fun!', titleStyle);
            playText.x = Math.round((bottom.width - playText.width) / 2);
            playText.y = app.screen.height - margin + Math.round((margin - playText.height) / 2);
            bottom.addChild(playText);

            //Wrex: Change this to image
            const muteText = new PIXI.Text('mute', infoStyle);
            muteText.x = muteText.width / 2;
            muteText.y = muteText.height / 2;
            muteText.interactive = true;
            muteText.buttonMode = true;
            muteText.on('pointerdown', () => {
                const muted = PIXI.sound.toggleMuteAll();
                muteText.text = muted ? 'unmute' : 'mute';
            });
            left.addChild(muteText);

            const moneyText = new PIXI.Text('$' + money, infoStyle);
            moneyText.x = app.screen.width - REEL_WIDTH + REEL_WIDTH / 2 - moneyText.width / 2;
            moneyText.y = margin + moneyText.height / 2;
            right.addChild(moneyText);

            const currentBetText = new PIXI.Text('Bet: ' + getCurrentBet(), infoStyle);
            currentBetText.x = app.screen.width - REEL_WIDTH + REEL_WIDTH / 2 - currentBetText.width / 2;
            currentBetText.y = margin + moneyText.height + currentBetText.height / 2;

            currentBetText.interactive = true;
            currentBetText.buttonMode = true;
            currentBetText.on('pointerdown', () => {
                onBetClicked(currentBetText);
            });

            right.addChild(currentBetText);

            app.stage.addChild(reelContainer);
            app.stage.addChild(top);
            app.stage.addChild(bottom);
            app.stage.addChild(left);
            app.stage.addChild(right);


            // Set the interactivity.
            bottom.interactive = true;
            bottom.buttonMode = true;
            bottom.addListener('pointerdown', () => {
                startPlay();
            });

            let running = false;

            function onBetClicked(currentBetText) {
                incrementBet();
                currentBetText.text = 'Bet: ' + getCurrentBet();
            }

            function getCurrentBet() {
                return BET_OPTIONS[betIndex];
            }

            function incrementBet() {
                betIndex++;
                betIndex %= BET_OPTIONS.length;
            }

            // Function to start playing.
            function startPlay() {
                if (running) return;
                running = true;
                money -= getCurrentBet();
                moneyText.text = '$' + money;

                for (let i = 0; i < reels.length; i++) {
                    const r = reels[i];
                    //Wrex: This should be some sort of smart formula...
                    const extra = Math.floor(Math.random() * 3);
                    const target = r.position + 10 + i * 5 + extra;
                    const time = 2500 + i * 600 + extra * 600;
                    tweenTo(r, 'position', target, time, backout(0.5), null, i === reels.length - 1 ? reelsComplete : reelComplete);
                }
            }

            // Reels done handler.
            function reelComplete() {
                console.log("Single Done");
            }

            // Reels done handler.
            function reelsComplete() {
                running = false;
                console.log("Fully Done");

                let sound = PIXI.sound.Sound.from(manifest.succesSfx);
                sound.play({
                    volume: 0.2 //sound is  too loud
                });

            }

            // Listen for animate update.
            app.ticker.add((delta) => {
                // Update the slots.
                for (let i = 0; i < reels.length; i++) {
                    const r = reels[i];
                    // Update blur filter y amount based on speed.
                    // This would be better if calculated with time in mind also. Now blur depends on frame rate.
                    r.blur.blurY = (r.position - r.previousPosition) * 8;
                    r.previousPosition = r.position;

                    // Update symbol positions on reel.
                    for (let j = 0; j < r.symbols.length; j++) {
                        const symbol = r.symbols[j];
                        const previousY = symbol.y;
                        symbol.y = ((r.position + j) % r.symbols.length) * SYMBOL_SIZE - SYMBOL_SIZE;
                        if (symbol.y < 0 && previousY > SYMBOL_SIZE) {
                            // Detect going over and swap a texture.
                            // This should in proper product be determined from some logical reel.
                            var symbolId = getNextSymbolId(i);
                            symbol.texture = slotTextures[symbolId];
                            symbol.scale.x = symbol.scale.y = Math.min(SYMBOL_SIZE / symbol.texture.width, SYMBOL_SIZE / symbol.texture.height);
                            symbol.x = (REEL_WIDTH / 2) - (symbol.width * symbol.scale.x) / 2;
                        }
                    }
                }
            });
        });

        // Very simple tweening utility function. This should be replaced with a proper tweening library in a real product.
        const tweening = [];
        function tweenTo(object, property, target, time, easing, onchange, oncomplete) {
            const tween = {
                object,
                property,
                propertyBeginValue: object[property],
                target,
                easing,
                time,
                change: onchange,
                complete: oncomplete,
                start: Date.now(),
            };

            tweening.push(tween);
            return tween;
        }

        // Listen for animate update.
        app.ticker.add((delta) => {
            const now = Date.now();
            const remove = [];
            for (let i = 0; i < tweening.length; i++) {
                const t = tweening[i];
                const phase = Math.min(1, (now - t.start) / t.time);

                t.object[t.property] = lerp(t.propertyBeginValue, t.target, t.easing(phase));
                if (t.change) t.change(t);
                if (phase === 1) {
                    t.object[t.property] = t.target;
                    if (t.complete) t.complete(t);
                    remove.push(t);
                }
            }
            for (let i = 0; i < remove.length; i++) {
                tweening.splice(tweening.indexOf(remove[i]), 1);
            }
        });

        // Basic lerp funtion.
        function lerp(a1, a2, t) {
            return a1 * (1 - t) + a2 * t;
        }

        // Backout function from tweenjs.
        // https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js
        function backout(amount) {
            return (t) => (--t * t * ((amount + 1) * t + amount) + 1);
        }
    </script>
</body>
</html>
